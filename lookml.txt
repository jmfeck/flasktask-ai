Yes, what you're describing is both possible and recommended in Looker. This approach gives you a structured, maintainable setup by separating concerns, and it works well for managing large datasets. Here's how you can implement it step by step:

### 1. **Autogenerated Views (Base Layer)**:
   - When Looker connects to a new table in your database, it can automatically generate a view file based on that tableâ€™s schema. This autogenerated view will contain all the fields (dimensions and measures) based on the columns.
   - You can keep this autogenerated view as a base layer, without making any major changes directly here.

### 2. **Field Organization (Folders Layer)**:
   - You can create a **customized layer** where you organize the fields in **folders** (technically called **field sets** in LookML). This allows you to categorize your fields to make them more intuitive for end users.
   - Example:
     ```lookml
     view: orders {
       dimension: order_id {
         sql: ${TABLE}.order_id ;;
       }
       dimension: order_date {
         sql: ${TABLE}.order_date ;;
       }

       # Organizing fields into folders
       group_label: "Order Info" {
         field: order_id
         field: order_date
       }

       group_label: "Revenue Info" {
         field: revenue
         field: profit
       }
     }
     ```
   - By grouping related fields into different folders, you enhance the user experience when they explore the data.

### 3. **Create Explores with Selected Fields (Exploration Layer)**:
   - In your explores, you can **inherit from the views** and **only select the fields** that are relevant to the particular explore, while keeping the underlying structure.
   - This helps you create more focused explores for specific user groups or use cases.
   - Example:
     ```lookml
     explore: orders {
       view_name: orders
       fields: [order_id, order_date, revenue]  # Only include the fields of interest
     }
     ```

### 4. **Add Row-Level Security**:
   - You can apply row-level security to restrict data access based on user attributes. This can be done by using `access_filter` or `sql_always_where`.
   - Example of adding row-level security based on user roles:
     ```lookml
     explore: orders {
       view_name: orders
       access_filter: {
         field: orders.region
         user_attribute: region
       }
     }
     ```
   - This ensures users only see the rows of data they are authorized to view.

### Benefits of this Approach:
   - **Maintainability**: Your base views remain untouched, and all custom logic (field organization, security, selected fields) is applied at the explore level.
   - **Reusability**: The same view can be reused across multiple explores, each having different configurations based on the audience.
   - **Clear Structure**: Organizing fields into folders makes it easier for users to find and explore the data they need.

By layering your LookML this way, you achieve a flexible, scalable design. Let me know if you want help with specific LookML examples or further customization!